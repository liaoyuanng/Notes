# 读《图解 HTTP》笔记

## ARP 协议

ARP协议(`Address Resolution Protocol`)，即地址解析协议。是根据`IP`地址获取物理地址(MAC)的`TCP/IP协议`。

// TODO : https://baike.baidu.com/item/ARP/609343?fr=aladdin&fromid=1742212&fromtitle=ARP%E5%8D%8F%E8%AE%AE

## TCP

`TCP`位于传输层，提供可靠的字节流(注意这里的描述**字节流**,所以 TCP 是流，而不是包)服务。为了准确无误的将数据送达目标，`TCP`协议采用三次握手(three-way handshaking) 策略:

1. 首先，发送端发送一个带 SYN 标志的数据包给接收端。
2. 接收到收到后，回传一个带有 SYN/ACK 的数据包
3. 发送端再回传一个带 ACK 标志的数据包。握手结束。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15149932337872.jpg)

HTTP请求示意图

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153084818984.jpg)



## URL 和 URI

`URL`表示资源的地点(互联网上所处的位置)。`URI` 表示字符串标识某一互联网资源。`URL`是`URI`的子集。`URI`表示互联网上某个资源，它包含`URL`和`URN`(统一资源名称)，而`URL`则表示这个资源具体的位置。比如你有一台 MAC 电脑，我也有一台 MAC 电脑，这都是`URI`，但是，怎么区分呢，继续拿这个举例子，比如你在河南郑州，那么可以简单表示为:`地址：河南/郑州/你家/MAC`，而我在上海，表示为`地址：上海/静安/我家/MAC`，这就是`URL`。因为现在`URN`已经很少见了，所以现在基本上见到的既是`URI`也是`URL`。

## 请求和响应

HTTP 协议规定：请求从`客户端`发出，`服务器`端回复响应。

### 请求

请求报文是由`请求方法`、`请求URI`、`协议版本`、`可选的请求首部字段`和`内容实体`构成的。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153061515839.jpg)


请求方法有下面几种：


| 方法 | 说明 | 协议版本 |
| :-: | :-: | :-: |
| GET | 获取资源 | 1.0、1.1  |
| POST | 传输实体主体 | 1.0、1.1 |
| PUT | 传输文件 | 1.0、1.1 |
| HEAD | 获取报文首部 | 1.0、1.1 |
| DELETE | 删除文件 | 1.0、1.1 |
| OPTIONS | 询问支持的方法 | 1.1 |
| TRACE | 追踪路径 | 1.1  |
| CONNECT | 要求用隧道协议连接代理 | 1.1 |
| LINK(已废弃) | 建立和资源之间的联系 | 1.0 |
| UNLINK(已废弃) | 断开连接关系 | 1.0 |

其中，`HEAD`方法是获得报文首部，和`GET`方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。`PUT`和`DELETE`方法由于不带验证机制，所以一般不使用。`OPTIONS`方法用查询针对请求URI指定资源支持的方法。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153071237018.jpg)

`TRACE`方法用来追踪请求经过的转发，在`Max-Forwards`首部字段中填入数值，每经过一个服务器端就将该数字减一，当数值刚好减到0时，就停止继续传输。这个方法不常用，而且容易被`XST（跨站追踪）`攻击。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153078439847.jpg)

`CONNECT`方法要求在与代理服务器通信时，建立隧道，实现用隧道协议进行`TCP`通信。主要使用`SSL`和`TLS`一些把通信内容加密后经网络隧道传输。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153080039011.jpg)

### 请求中的持久连接

在 HTTP 协议的初始版本中，每一次 HTTP 通信都要断开一次 TCP 连接，因为之前都是很小的文本传输, 所以也没有什么问题，但慢慢的，图片的需求越来越多，在一个`HTML`页面可能有多张图片，而这些图片（资源）需要单独的请求获取，就造成了没有必要的 TCP 的建立和断开。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153089067780.jpg)

为了解决这个问题，就出现了`持久连接(HTTP keep-alive)`的方法。只要任意一端没有明确提出断开连接，就会继续保持`TCP`连接状态。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153090084089.jpg)


### Cookie

由于**HTTP是无状态协议**，它不对之前发生过的请求和响应进行管理，无法根据之前的状态进行本次的请求处理。比如一个电商页面，用户登录后，然后进行购买，但是这个时候服务器端并不知道他已经登录了，需要附加额外的参数来管理登录状态。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153141156009.jpg)

为了解决这个问题，所以引入了`Cookie`技术。

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

1. 客户端第一次请求，这个时候没有`Cookie`信息。
2. 服务器端发送的响应报文内增加一个`Set-Cookie`的首部字段信息，通知客户端保存`Cookie`。
3. 客户端再次请求的时候，客户端会自动在报文中加入`Cookie`值发送出去。
4. 这样，服务器端就能够知道这个客户端之前的状态。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153144988830.jpg)

#### 响应

响应报文基本上由`协议版本`、`状态码`（表示请求成功或失败的数字代码）、`用以解释状态码的原因短语`、`可选的响应首部字段`以及`实体主体`构成.

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153065402666.jpg)

### HTTP 报文

用于 HTTP 协议交互的信息称为 HTTP 报文。请求端的是请求报文，响应端的是响应报文。报文大致可分为报文首部和报文主体两块，两者之间通常用空行来划分。报文主体不是必须的。

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153183891618.jpg)

请求报文实例：

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153188871970.jpg)

响应报文实例

![](http://7xsgdb.com1.z0.glb.clouddn.com/15153189070154.jpg)


